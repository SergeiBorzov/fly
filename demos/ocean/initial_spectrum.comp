#version 460
#extension GL_GOOGLE_include_directive : enable
#include "bindless.glsl"

#define G (9.81f)
#define PI (3.14159265f)

layout(local_size_x = 256) in;

layout(push_constant) uniform PushConstants
{
    uint dataBufferIndex;
    uint uniformBufferIndex;
}
gPushConstants;

FLY_REGISTER_UNIFORM_BUFFER(UniformData, {
    vec4 fetchSpeedDirSpread;
    vec4 timeScale;
    vec4 domainMinMax;
})

FLY_REGISTER_STORAGE_BUFFER(writeonly, Data, {
    vec2 value;
    vec2 displacement;
    vec2 dx;
    vec2 dy;
})

float Hash(vec2 n, float seed)
{
    return fract(sin(dot(n + seed, vec2(12.9898, 78.233))) * 43758.5453);
}

// Box-Muller transform using two hashed values
float GaussianHash(vec2 n, float seed)
{
    float u1 = Hash(n, seed);
    float u2 = Hash(n, seed + 1.0);
    float r = sqrt(-2.0 * log(max(u1, 1e-6)));
    float theta = 2.0 * PI * u2;
    return r * cos(theta);
}

float Jonswap(float w, float fetch, float windSpeed)
{
    const float y = 3.3;
    const float wp = 22.0f * pow((windSpeed * fetch) / (G * G), -0.33f);
    const float sigma = w > wp ? 0.09f : 0.07f;
    const float alpha =
        0.076f * pow((G * fetch) / (windSpeed * windSpeed), -0.22f);
    const float r = exp(-((w - wp) * (w - wp)) / (2 * sigma * sigma * wp * wp));

    return ((alpha * G * G) / pow(w, 5.0f)) *
           exp(-(5.0f / 4.0f) * pow(wp / w, 4.0f)) * pow(y, r);
}

// Quartic approx for normalization factor for cosine-2s spread function
// accurate over s in [0.1, 20]
float NormalizationFactor(float s)
{
    return (((-1.87195e-5f * s + 9.67562e-4f) * s - 1.93905e-2f) * s +
            2.57321e-1f) *
               s +
           3.89014e-1f;
}

float Cosine2s(float theta, float theta0, float s)
{
    float delta = 0.5f * (theta - theta0);
    return NormalizationFactor(s) * pow(abs(cos(delta)), 2 * s);
}

float WaveDispersion(float kl) { return sqrt(G * kl); }
float WaveDispersionDerivative(float kl) { return G / (2 * sqrt(G * kl)); }

float Spectrum(float kl, float fetch, float windSpeed, float theta,
               float theta0, float spread)
{
    return Jonswap(WaveDispersion(kl), fetch, windSpeed) *
           Cosine2s(theta, theta0, spread) * WaveDispersionDerivative(kl) / kl;
}

vec2 H0(vec2 k, float kl, float deltaK, float fetch, float windSpeed,
        float theta, float theta0, float spread)
{
    vec2 rand = vec2(GaussianHash(k, 0.0f), GaussianHash(k, 1.0f));

    return rand / sqrt(2) *
           sqrt(2 * Spectrum(kl, fetch, windSpeed, theta, theta0, spread) *
                deltaK * deltaK);
}

void main()
{
    int c = int(gl_LocalInvocationID.x);
    int r = int(gl_WorkGroupID.x);
    int base = r * int(gl_WorkGroupSize.x);
    int size = int(gl_WorkGroupSize.x);

    vec4 domainMinMax = FLY_ACCESS_UNIFORM_BUFFER(
        UniformData, gPushConstants.uniformBufferIndex, domainMinMax);
    float deltaK = 2 * PI / domainMinMax.x;
    int halfSize = size / 2;
    float kx = (c < halfSize) ? c : c - size;
    float ky = (r < halfSize) ? r : r - size;
    vec2 k = vec2(kx, ky) * deltaK;
    float theta = atan(k.y, k.x);
    if (length(k) < 1e-4)
    {
        k.x = 0.0001;
        k.y = 0.0001;
    }
    float kl = length(k);

    vec4 fetchSpeedDirSpread = FLY_ACCESS_UNIFORM_BUFFER(
        UniformData, gPushConstants.uniformBufferIndex, fetchSpeedDirSpread);

    vec2 h0 = vec2(0.0f);
    if (kl > domainMinMax.y && kl < domainMinMax.z)
    {
        h0 = H0(k, kl, deltaK, fetchSpeedDirSpread.x, fetchSpeedDirSpread.y,
                theta, fetchSpeedDirSpread.z, fetchSpeedDirSpread.w);
    }

    Data data = Data(h0, vec2(0.0f), vec2(0.0f), vec2(0.0f));
    FLY_ACCESS_STORAGE_BUFFER(Data, gPushConstants.dataBufferIndex)
    [base + c] = data;
}
