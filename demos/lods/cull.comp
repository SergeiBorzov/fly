#version 460
#extension GL_GOOGLE_include_directive : enable
#include "bindless.glsl"

#define MAX_LOD_COUNT 8

layout(local_size_x = 256) in;

layout(push_constant) uniform PushConstants
{
    uint cameraBufferIndex;
    uint instanceBufferIndex;
    uint meshDataBufferIndex;
    uint lodInstanceOffsetBufferIndex;
    uint drawCommandBufferIndex;
    uint drawCountBufferIndex;
    uint instanceCount;
}
gPushConstants;

FLY_REGISTER_UNIFORM_BUFFER(Camera, {
    mat4 projection;
    mat4 view;
    vec4 screenSize;
    float near;
    float far;
    float halfTanFovHorizontal;
    float halfTanFovVertical;
})

FLY_REGISTER_STORAGE_BUFFER(writeonly, VkDrawIndexedIndirectCommand, {
    uint indexCount;
    uint instanceCount;
    uint firstIndex;
    int vertexOffset;
    uint firstInstance;
})

FLY_REGISTER_STORAGE_BUFFER(readonly, MeshData, {
    vec3 sphereCenter;
    float sphereRadius;
    uint lodCount;
})

FLY_REGISTER_STORAGE_BUFFER(readonly, MeshInstance, {
    vec3 position;
    float pad;
})

FLY_REGISTER_STORAGE_BUFFER(writeonly, LodInstanceOffset, {
    int lodIndex;
    uint localInstanceOffset;
})

layout(set = 0,
       binding = FLY_STORAGE_BUFFER_BINDING_INDEX) writeonly buffer DrawCount
{
    uint count;
}
gDrawCountBuffers[];

const float sizes[MAX_LOD_COUNT] = {
    0.5f, 0.25f, 0.125f, 0.0625f, 0.03125f, 0.015625f, 0.0078125f, 0.00390625};

int SelectLodIndex(vec3 positionVS, float sphereRadius, uint lodCount,
                   float invHalfTanFovHorizontal)
{
    float dist = max(-positionVS.z - sphereRadius, 0.001f);

    float sizeRelativeToScreen =
        (sphereRadius / dist) * invHalfTanFovHorizontal;

    int lodIndex = 0;
    for (int i = 0; i < lodCount; i++)
    {
        if (sizeRelativeToScreen < sizes[i])
        {
            lodIndex = i;
        }
    }
    return lodIndex;
}

bool FrustumCulling(vec3 centerVS, float sphereRadius, float near, float far,
                    float halfTanFovHorizontal, float halfTanFovVertical)
{
    bool visible =
        -centerVS.z + sphereRadius > near && -centerVS.z - sphereRadius < far;
    visible =
        visible &&
        -centerVS.z * halfTanFovHorizontal + sphereRadius - abs(centerVS.x) > 0;
    visible =
        visible &&
        -centerVS.z * halfTanFovVertical + sphereRadius - abs(centerVS.y) > 0;
    return visible;
}

void main()
{
    uint index = gl_GlobalInvocationID.x;
    if (index >= gPushConstants.instanceCount)
    {
        return;
    }

    if (index < 8)
    {
        FLY_ACCESS_STORAGE_BUFFER(VkDrawIndexedIndirectCommand,
                                  gPushConstants.drawCommandBufferIndex)
        [index].instanceCount = 0;
    }
    barrier();

    if (index == 0)
    {
        gDrawCountBuffers[gPushConstants.drawCountBufferIndex].count = 8;
    }
    barrier();

    // Only dragon mesh in the scene
    MeshData meshData = FLY_ACCESS_STORAGE_BUFFER(
        MeshData, gPushConstants.meshDataBufferIndex)[0];

    mat4 projection = FLY_ACCESS_UNIFORM_BUFFER(
        Camera, gPushConstants.cameraBufferIndex, projection);
    mat4 view = FLY_ACCESS_UNIFORM_BUFFER(
        Camera, gPushConstants.cameraBufferIndex, view);
    float near = FLY_ACCESS_UNIFORM_BUFFER(
        Camera, gPushConstants.cameraBufferIndex, near);
    float far = FLY_ACCESS_UNIFORM_BUFFER(
        Camera, gPushConstants.cameraBufferIndex, far);
    float halfTanFovHorizontal = FLY_ACCESS_UNIFORM_BUFFER(
        Camera, gPushConstants.cameraBufferIndex, halfTanFovHorizontal);
    float halfTanFovVertical = FLY_ACCESS_UNIFORM_BUFFER(
        Camera, gPushConstants.cameraBufferIndex, halfTanFovVertical);

    vec3 translation =
        FLY_ACCESS_STORAGE_BUFFER(MeshInstance,
                                  gPushConstants.instanceBufferIndex)[index]
            .position;
    vec4 positionVS = view * vec4(meshData.sphereCenter + translation, 1.0f);

    int lodIndex = -1;
    uint localInstanceOffset = 0;

    bool visible =
        FrustumCulling(positionVS.xyz, meshData.sphereRadius, near, far,
                       halfTanFovHorizontal, halfTanFovVertical);
    if (visible)
    {
        lodIndex = SelectLodIndex(positionVS.xyz, meshData.sphereRadius,
                                  meshData.lodCount, projection[0][0]);

        localInstanceOffset =
            atomicAdd(FLY_ACCESS_STORAGE_BUFFER(
                          VkDrawIndexedIndirectCommand,
                          gPushConstants.drawCommandBufferIndex)[lodIndex]
                          .instanceCount,
                      1);
    }

    FLY_ACCESS_STORAGE_BUFFER(LodInstanceOffset,
                              gPushConstants.lodInstanceOffsetBufferIndex)
    [index] = LodInstanceOffset(lodIndex, localInstanceOffset);
}
