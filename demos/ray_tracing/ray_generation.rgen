#version 460
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_ray_tracing : require

#include "bindless.glsl"
#include "common.glsl"

layout(location = 0) rayPayloadEXT Payload payload;

FLY_REGISTER_UNIFORM_BUFFER(Camera, {
    mat4 projection;
    mat4 view;
})

FLY_REGISTER_STORAGE_TEXTURE_BUFFER(, StorageTexturesRGBA16F, image2D, rgba16f)

FLY_REGISTER_ACCELERATION_STRUCTURE_BUFFER(AccStructures)

uint Xorshift32(inout uint seed)
{
    seed = seed ^ 61u ^ (seed >> 16);
    seed *= 9u;
    seed = seed ^ (seed >> 4);
    seed *= 0x27d4eb2du;
    seed = seed ^ (seed >> 15);
    return seed;
}

float RandomFloat(inout uint seed)
{
    return float(Xorshift32(seed)) / 4294967296.0;
}

vec3 SampleHemisphere(vec2 p, vec3 n)
{
    float phi = 2.0f * PI * p.x;
    float cosTheta = sqrt((1.0f - p.y));
    float sinTheta = sqrt(p.y);

    vec3 h;
    h.x = cos(phi) * sinTheta;
    h.y = cosTheta;
    h.z = sin(phi) * sinTheta;

    vec3 up =
        abs(n.y) < 0.999f ? vec3(0.0f, 1.0f, 0.0f) : vec3(1.0f, 0.0f, 0.0f);
    vec3 tangent = normalize(cross(up, n));
    vec3 bitangent = cross(n, tangent);

    vec3 sampleVec = tangent * h.x + n * h.y + bitangent * h.z;
    return normalize(sampleVec);
}

void main()
{
    vec2 uv = (vec2(gl_LaunchIDEXT.xy) + 0.5f) / gl_LaunchSizeEXT.xy;

    mat4 inverseProjection = inverse(FLY_ACCESS_UNIFORM_BUFFER(
        Camera, gPushConstants.cameraBufferIndex, projection));
    mat4 inverseView = inverse(FLY_ACCESS_UNIFORM_BUFFER(
        Camera, gPushConstants.cameraBufferIndex, view));

    vec4 clipPos = vec4(2.0f * uv - 1.0f, 0.0f, 1.0f);
    vec4 viewPos = inverseProjection * clipPos;
    viewPos /= viewPos.w;
    vec3 rayDirVS = normalize(viewPos.xyz);
    vec3 rayDirWS = normalize(inverseView * vec4(rayDirVS, 0.0f)).xyz;

    vec3 rayOriginWS = inverseView[3].xyz;

    payload.throughput = vec3(1.0f);
    payload.luminance = vec3(0.0f);
    payload.seed = uint(gl_LaunchIDEXT.x) * 1973u +
                   uint(gl_LaunchIDEXT.y) * 9277u +
                   gPushConstants.currentSample * 1013u + 1u;

    payload.maxSamples = gPushConstants.sampleCount;
    payload.depth = 0;
    payload.p = vec3(0.0f);
    payload.n = vec3(0.0f);

    for (int bounce = 0; bounce < MAX_BOUNCES; bounce++)
    {
        traceRayEXT(FLY_ACCESS_ACCELERATION_STRUCTURE_BUFFER(
                        AccStructures, gPushConstants.accStructureIndex),
                    gl_RayFlagsOpaqueEXT, 0xFF, 0, gPushConstants.sbtStride, 0,
                    rayOriginWS, 0.0f, rayDirWS, 1000.0f, 0);

        if (payload.done == 1)
        {
            break;
        }

        rayOriginWS = payload.p + payload.n * EPS;
        float alpha = RandomFloat(payload.seed);
        if (alpha < payload.reflectionCoeff)
        {
            rayDirWS = normalize(reflect(rayDirWS, payload.n));
        }
        else
        {
            rayDirWS = SampleHemisphere(
                vec2(RandomFloat(payload.seed), RandomFloat(payload.seed)),
                payload.n);
        }
    }

    vec3 accLuminance = imageLoad(FLY_ACCESS_STORAGE_TEXTURE_BUFFER(
                                      StorageTexturesRGBA16F,
                                      gPushConstants.outputTextureIndex),
                                  ivec2(gl_LaunchIDEXT.xy))
                            .rgb;
    vec3 luminance =
        (accLuminance * gPushConstants.currentSample + payload.luminance) /
        (gPushConstants.currentSample + 1);
    imageStore(FLY_ACCESS_STORAGE_TEXTURE_BUFFER(
                   StorageTexturesRGBA16F, gPushConstants.outputTextureIndex),
               ivec2(gl_LaunchIDEXT.xy), vec4(luminance, 1.0f));
}
