#version 460
#extension GL_GOOGLE_include_directive : enable
#include "bindless.glsl"

layout(local_size_x = 16, local_size_y = 16) in;

// (1.0f + sqrt(5.0f))/2.0f
#define GOLDEN_RATIO 1.6180339f
#define PI 3.14159265359f
#define MIE_G 0.8f

layout(push_constant) uniform PushConstants
{
    uint atmosphereBufferIndex;
    uint transmittanceMapIndex;
    uint multiscatteringMapIndex;
}
gPushConstants;

FLY_REGISTER_UNIFORM_BUFFER(AtmosphereParams, {
    vec3 rayleighScattering;
    float mieScattering;
    vec3 ozoneAbsorption;
    float mieAbsorption;
    vec2 transmittanceMapDims;
    float rb;
    float rt;
    vec2 multiscatteringMapDims;
})

FLY_REGISTER_TEXTURE_BUFFER(Textures, sampler2D)
FLY_REGISTER_STORAGE_TEXTURE_BUFFER(writeonly, RGBA16FTextures, image2D,
                                    rgba16f)

float SafeSqrt(float x) { return sqrt(max(0.0f, x)); }
float RaySphereIntersect(vec3 o, vec3 d, vec3 p, float r)
{
    float b = dot(o - p, d);
    float c = dot(o - p, o - p) - r * r;

    float disc = b * b - c;
    if (disc < 0.0f)
    {
        return -1.0f;
    }

    float t = (-b - sqrt(disc));
    if (t < 0.0f)
    {
        t = (-b + sqrt(disc));
    }
    return t;
}

float DensityRayleigh(float h) { return exp(-h / 8.0f); }

float DensityMie(float h) { return exp(-h / 1.2f); }

float DensityOzone(float h) { return max(0.0f, 1.0f - abs(h - 25.0f) / 15.0f); }

vec3 SampleExtinction(float height)
{
    vec3 rayleighScattering = FLY_ACCESS_UNIFORM_BUFFER(
        AtmosphereParams, gPushConstants.atmosphereBufferIndex,
        rayleighScattering);
    float mieScattering = FLY_ACCESS_UNIFORM_BUFFER(
        AtmosphereParams, gPushConstants.atmosphereBufferIndex, mieScattering);
    vec3 ozoneAbsorption = FLY_ACCESS_UNIFORM_BUFFER(
        AtmosphereParams, gPushConstants.atmosphereBufferIndex,
        ozoneAbsorption);
    float mieAbsorption = FLY_ACCESS_UNIFORM_BUFFER(
        AtmosphereParams, gPushConstants.atmosphereBufferIndex, mieAbsorption);

    vec3 extinction = vec3(0.0f);
    extinction += rayleighScattering * DensityRayleigh(height);
    extinction += (mieScattering + mieAbsorption) * DensityMie(height);
    extinction += ozoneAbsorption * DensityOzone(height);

    return extinction;
}

vec3 SampleScattering(float height)
{
    vec3 rayleighScattering = FLY_ACCESS_UNIFORM_BUFFER(
        AtmosphereParams, gPushConstants.atmosphereBufferIndex,
        rayleighScattering);
    float mieScattering = FLY_ACCESS_UNIFORM_BUFFER(
        AtmosphereParams, gPushConstants.atmosphereBufferIndex, mieScattering);

    vec3 scattering = vec3(0.0f);
    scattering += rayleighScattering * DensityRayleigh(height);
    scattering += mieScattering * DensityMie(height);

    return scattering;
}

vec3 RayleighScattering(float height)
{
    vec3 rayleighScattering = FLY_ACCESS_UNIFORM_BUFFER(
        AtmosphereParams, gPushConstants.atmosphereBufferIndex,
        rayleighScattering);
    return rayleighScattering * DensityRayleigh(height);
}

float PhaseRayleigh(float cosTheta)
{
    return (3.0f / (4.0f * 4.0f * PI)) * (1 + cosTheta * cosTheta);
}

float PhaseMie(float cosTheta, float g)
{
    return (3.0f * (1 - g * g) * (1 + cosTheta * cosTheta)) /
           (2 * 4 * PI * (2 + g * g) * pow(1 + g * g - 2 * g * cosTheta, 1.5f));
}

float MieScattering(float height)
{
    float mieScattering = FLY_ACCESS_UNIFORM_BUFFER(
        AtmosphereParams, gPushConstants.atmosphereBufferIndex, mieScattering);
    return mieScattering * DensityMie(height);
}

vec2 TransmittanceParamsToUV(float r, float cosZ, float rb, float rt)
{
    float h = sqrt(rt * rt - rb * rb);
    float rho = SafeSqrt(r * r - rb * rb);

    float dMin = rt - r;
    float dMax = rho + h;

    float disc = r * r * (cosZ * cosZ - 1) + rt * rt;
    // Note that d1 has no chance to be positive, so solution is only d2
    // d1 = -r * cosZ - SafeSqrt(det);
    // d2 = -r * cosZ + SafeSqrt(det);
    float d = max(0.0f, -r * cosZ + SafeSqrt(disc));

    float u = clamp(rho / h, 0.0f, 0.99f);
    float v = clamp((d - dMin) / (dMax - dMin), 0.0f, 0.99f);

    return vec2(u, v);
}

vec3 SampleTransmittance(float r, float cosZ, float rb, float rt)
{
    // ivec2 coords = ivec2(TransmittanceParamsToUV(r, cosZ, rb, rt) * 1024.0f);
    // return imageLoad(FLY_ACCESS_TEXTURE_BUFFER(
    //                      Textures, gPushConstants.transmittanceMapIndex),
    //                  coords)
    //     .rgb;
    return texture(FLY_ACCESS_TEXTURE_BUFFER(
                       Textures, gPushConstants.transmittanceMapIndex),
                   TransmittanceParamsToUV(r, cosZ, rb, rt))
        .rgb;
}

vec3 IntegrateLf(vec3 worldPos, vec3 dir, float rb, float rt, uint sampleCount)
{
    vec3 planetOrigin = vec3(0.0f);
    float integrationLength =
        RaySphereIntersect(worldPos, dir, planetOrigin, rt);
    integrationLength = max(integrationLength, 0.0f);
    float delta = integrationLength / sampleCount;

    vec3 lf = vec3(0.0f);
    vec3 opticalDepth = vec3(0.0f);
    for (uint i = 0; i < sampleCount; i++)
    {
        vec3 p = worldPos + (i + 0.5f) * delta * dir;
        float r = length(p);
        float height = max(r - rb, 0.0f);

        vec3 t = exp(-opticalDepth);
        lf += t * SampleScattering(height) * delta;
        opticalDepth += SampleExtinction(height) * delta;
    }
    return lf;
}

vec3 IntegrateFms(vec3 worldPos, float rb, float rt, uint sampleCount)
{
    vec3 fms = vec3(0.0f);
    float delta = 1.0f / float(sampleCount);

    for (uint i = 0u; i < sampleCount; i++)
    {
        float fi = float(i) + 0.5f;
        float phi = acos(1.0f - 2.0f * fi / float(sampleCount));
        float theta = PI * GOLDEN_RATIO * fi;
        vec3 dir = vec3(cos(theta) * sin(phi), cos(phi), sin(theta) * sin(phi));

        fms += max(IntegrateLf(worldPos, -dir, rb, rt, 40) * delta, 0.0f);
    }
    return clamp(fms, 0.0f, 0.99f);
}

// Single scattering for unit illuminance
// Important!:
// Phase function here is uniform p = 1/(4*PI)
// We want view-independent approximation in our LUT
vec3 IntegrateL1(vec3 worldPos, vec3 dir, vec3 l, float rb, float rt,
                 uint sampleCount)
{
    vec3 planetOrigin = vec3(0.0f);
    float integrationLength =
        max(RaySphereIntersect(worldPos, dir, planetOrigin, rt), 0.0f);
    float delta = integrationLength / sampleCount;

    vec3 unitLum = vec3(0.0f);
    vec3 opticalDepth = vec3(0.0f);
    for (uint i = 0; i < sampleCount; i++)
    {
        float fi = float(i) + 0.5f;
        vec3 p = worldPos + fi * dir * delta;
        float r = length(p);
        float height = max(r - rb, 0.0f);
        float cosZ = dot(normalize(p), l);

        vec3 tIncrease = exp(-opticalDepth * delta);
        vec3 s = SampleTransmittance(r, cosZ, rb,
                                     rt); // TODO: Vis term (shadow factor)

        unitLum += (s * SampleScattering(height)) * delta;
        opticalDepth += SampleExtinction(height) * delta;
        // t *= tIncrease;
    }

    // unitLum += exp(-opticalDepth)*L0 // TODO: (surface reflection)

    return unitLum;
}

// Second order scattering for normalized unit illuminance
vec3 IntegrateL2(vec3 worldPos, vec3 l, float rb, float rt, uint sampleCount)
{
    vec3 unitLum = vec3(0.0f);
    float delta = 1.0f / float(sampleCount);

    for (uint i = 0; i < sampleCount; i++)
    {
        float fi = float(i) + 0.5f;
        float phi = acos(1.0f - 2.0f * fi / float(sampleCount));
        float theta = PI * GOLDEN_RATIO * fi;
        vec3 dir = normalize(
            vec3(cos(theta) * sin(phi), cos(phi), sin(theta) * sin(phi)));

        unitLum += IntegrateL1(worldPos, -dir, l, rb, rt, 200) * delta;
    }

    return unitLum;
}

vec2 TexToRadiusCosZenith(vec2 uv, float rb, float rt)
{
    float r = mix(rb, rt, uv.y);
    float cosZ = 2.0f * uv.x - 1.0f;
    return vec2(r, cosZ);
}

void main()
{
    float rb = FLY_ACCESS_UNIFORM_BUFFER(
        AtmosphereParams, gPushConstants.atmosphereBufferIndex, rb);
    float rt = FLY_ACCESS_UNIFORM_BUFFER(
        AtmosphereParams, gPushConstants.atmosphereBufferIndex, rt);
    vec2 dims = FLY_ACCESS_UNIFORM_BUFFER(AtmosphereParams,
                                          gPushConstants.atmosphereBufferIndex,
                                          multiscatteringMapDims);
    vec2 uv = (gl_GlobalInvocationID.xy + 0.5f) / dims;

    vec2 rcz = TexToRadiusCosZenith(uv, rb, rt);
    vec3 t = SampleTransmittance(rcz.x, rcz.y, rb, rt);

    vec3 worldPos = vec3(0.0f, rcz.x, 0.0f);
    vec3 l = vec3(SafeSqrt(1.0f - rcz.y * rcz.y), rcz.y, 0.0f);

    vec3 fms = IntegrateFms(worldPos, rb, rt, 200);
    vec3 psi = IntegrateL2(worldPos, l, rb, rt, 200);

    imageStore(FLY_ACCESS_STORAGE_TEXTURE_BUFFER(
                   RGBA16FTextures, gPushConstants.multiscatteringMapIndex),
               ivec2(gl_GlobalInvocationID.xy), vec4(psi / (1.0 - fms), 1.0f));
}
