#version 460
#extension GL_GOOGLE_include_directive : require
#include "common.glsl"

#define MULTISCATTERING_STEP_COUNT 20

layout(local_size_x = 16, local_size_y = 16) in;

layout(push_constant) uniform PushConstants
{
    uint atmosphereBufferIndex;
    uint transmittanceMapIndex;
    uint multiscatteringMapIndex;
}
gPushConstants;

vec3 IntegratePsi(vec3 worldPos, vec3 l, float rb, float rt)
{
    vec3 groundAlbedo = vec3(0.3);
    vec3 fms = vec3(0.0f);
    vec3 l2 = vec3(0.0f);
    vec3 planetOrigin = vec3(0.0f);

    float delta1 = 1.0f / float(MULTISCATTERING_STEP_COUNT);

    for (uint i = 0; i < MULTISCATTERING_STEP_COUNT; i++)
    {
        float fi = float(i) + 0.5f;
        float phi = acos(1.0f - 2.0f * fi / float(MULTISCATTERING_STEP_COUNT));
        float theta = 2 * PI * GOLDEN_RATIO * fi;

        vec3 dir = vec3(sin(phi) * sin(theta), cos(phi), sin(phi) * cos(theta));

        float integrationLength =
            RaySphereIntersect(worldPos, dir, planetOrigin, rt);
        if (integrationLength < 0.0f)
        {
            return vec3(0.0f);
        }

        float groundDist = RaySphereIntersect(worldPos, dir, planetOrigin, rb);
        if (groundDist > 0.0f)
        {
            integrationLength = groundDist;
        }

        float delta2 = integrationLength / float(MULTISCATTERING_STEP_COUNT);
        vec3 lum = vec3(0.0f);
        vec3 lumF = vec3(0.0f);
        vec3 transmittance = vec3(1.0f);

        float cosTheta = dot(-dir, l);

        for (uint j = 0; j < MULTISCATTERING_STEP_COUNT; j++)
        {
            float fj = float(j) + 0.5f;
            vec3 p = worldPos + fj * dir * delta2;

            float r = length(p);
            float height = max(r - rb, 0.0f);
            float cosZ = dot(l, normalize(p));

            vec3 extinction = max(
                SampleExtinction(height, gPushConstants.atmosphereBufferIndex),
                1e-7);
            vec3 stepTransmittance = exp(-delta2 * extinction);

            vec3 scatteringNoPhase =
                SampleScattering(height, gPushConstants.atmosphereBufferIndex);
            // Assuming extinction is constant on step segment
            // Integrating analytically
            lumF += transmittance * scatteringNoPhase *
                    (1.0f - stepTransmittance) / extinction;

            vec3 s = SampleTransmittance(r, cosZ, rb, rt,
                                         gPushConstants.transmittanceMapIndex);
            vec3 scattering = scatteringNoPhase * PHASE_UNIFORM;

            lum += transmittance * scattering * s * (1.0f - stepTransmittance) /
                   extinction;

            transmittance *= stepTransmittance;
        }

        // if (groundDist > 0.0f)
        // {
        //     vec3 p = worldPos + groundDist * dir;
        //     float r = length(p);
        //     float cosZ = dot(l, normalize(p));

        //     lum += SampleTransmittance(max(r, rb), cosZ, rb, rt,
        //                                gPushConstants.transmittanceMapIndex)
        //                                *
        //            transmittance * (groundAlbedo / PI) * cosZ;
        // }

        fms += lumF * delta1 * PHASE_UNIFORM;
        l2 += lum * delta1 * PHASE_UNIFORM;
    }

    return l2 / (1.0f - fms);
}

vec2 UVToMultiscatteringRadiusCosZenith(vec2 uv, float rb, float rt)
{
    float r = mix(rb, rt, uv.y);
    float cosZ = 2.0f * uv.x - 1.0f;
    return vec2(r, cosZ);
}

void main()
{
    vec2 dims = FLY_ACCESS_UNIFORM_BUFFER(AtmosphereParams,
                                          gPushConstants.atmosphereBufferIndex,
                                          multiscatteringMapDims);
    vec2 uv = (gl_GlobalInvocationID.xy + 0.5f) / dims;

    float rb = FLY_ACCESS_UNIFORM_BUFFER(
        AtmosphereParams, gPushConstants.atmosphereBufferIndex, rb);
    float rt = FLY_ACCESS_UNIFORM_BUFFER(
        AtmosphereParams, gPushConstants.atmosphereBufferIndex, rt);

    vec2 rcz = UVToMultiscatteringRadiusCosZenith(uv, rb, rt);

    vec3 worldPos = vec3(0.0f, rcz.x, 0.0f);
    vec3 l = vec3(SafeSqrt(1.0f - rcz.y * rcz.y), rcz.y, 0.0f);

    vec3 psi = IntegratePsi(worldPos, l, rb, rt);

    imageStore(
        FLY_ACCESS_STORAGE_TEXTURE_BUFFER(
            StorageTexturesRGBA16F, gPushConstants.multiscatteringMapIndex),
        ivec2(gl_GlobalInvocationID.xy), vec4(psi, 1.0f));
}
