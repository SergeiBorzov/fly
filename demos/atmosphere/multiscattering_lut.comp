#version 460
#extension GL_GOOGLE_include_directive : enable
#include "bindless.glsl"

layout(local_size_x = 16, local_size_y = 16) in;

// (1.0f + sqrt(5.0f))/2.0f
#define GOLDEN_RATIO 1.6180339f
#define PI 3.14159265359f
#define MIE_G 0.8f
#define PHASE_UNIFORM (1.0f / (4.0f * PI))

layout(push_constant) uniform PushConstants
{
    uint atmosphereBufferIndex;
    uint transmittanceMapIndex;
    uint multiscatteringMapIndex;
}
gPushConstants;

FLY_REGISTER_UNIFORM_BUFFER(AtmosphereParams, {
    vec3 rayleighScattering;
    float mieScattering;
    vec3 ozoneAbsorption;
    float mieAbsorption;
    vec2 transmittanceMapDims;
    float rb;
    float rt;
    vec2 multiscatteringMapDims;
    vec2 skyviewMapDims;
    float zenith;
    float azimuth;
})

FLY_REGISTER_TEXTURE_BUFFER(Textures, sampler2D)
FLY_REGISTER_STORAGE_TEXTURE_BUFFER(writeonly, RGBA16FTextures, image2D,
                                    rgba16f)

float SafeSqrt(float x) { return sqrt(max(0.0f, x)); }
float RaySphereIntersect(vec3 o, vec3 d, vec3 p, float r)
{
    float b = dot(o - p, d);
    float c = dot(o - p, o - p) - r * r;

    float disc = b * b - c;
    if (disc < 0.0f)
    {
        return -1.0f;
    }

    float t = (-b - sqrt(disc));
    if (t < 0.0f)
    {
        t = (-b + sqrt(disc));
    }
    return t;
}

float DensityRayleigh(float h) { return exp(-h / 8.0f); }

float DensityMie(float h) { return exp(-h / 1.2f); }

float DensityOzone(float h) { return max(0.0f, 1.0f - abs(h - 25.0f) / 15.0f); }

vec3 SampleExtinction(float height)
{
    vec3 rayleighScattering = FLY_ACCESS_UNIFORM_BUFFER(
        AtmosphereParams, gPushConstants.atmosphereBufferIndex,
        rayleighScattering);
    float mieScattering = FLY_ACCESS_UNIFORM_BUFFER(
        AtmosphereParams, gPushConstants.atmosphereBufferIndex, mieScattering);
    vec3 ozoneAbsorption = FLY_ACCESS_UNIFORM_BUFFER(
        AtmosphereParams, gPushConstants.atmosphereBufferIndex,
        ozoneAbsorption);
    float mieAbsorption = FLY_ACCESS_UNIFORM_BUFFER(
        AtmosphereParams, gPushConstants.atmosphereBufferIndex, mieAbsorption);

    vec3 extinction = vec3(0.0f);
    extinction += rayleighScattering * DensityRayleigh(height);
    extinction += (mieScattering + mieAbsorption) * DensityMie(height);
    extinction += ozoneAbsorption * DensityOzone(height);

    return extinction;
}

vec3 SampleScattering(float height)
{
    vec3 rayleighScattering = FLY_ACCESS_UNIFORM_BUFFER(
        AtmosphereParams, gPushConstants.atmosphereBufferIndex,
        rayleighScattering);
    float mieScattering = FLY_ACCESS_UNIFORM_BUFFER(
        AtmosphereParams, gPushConstants.atmosphereBufferIndex, mieScattering);

    vec3 scattering = vec3(0.0f);
    scattering += rayleighScattering * DensityRayleigh(height);
    scattering += mieScattering * DensityMie(height);

    return scattering;
}

vec2 TransmittanceParamsToUV(float r, float cosZ, float rb, float rt)
{
    float h = sqrt(rt * rt - rb * rb);
    float rho = SafeSqrt(r * r - rb * rb);

    float dMin = rt - r;
    float dMax = rho + h;

    float disc = r * r * (cosZ * cosZ - 1) + rt * rt;
    // Note that d1 has no chance to be positive, so solution is only d2
    // d1 = -r * cosZ - SafeSqrt(det);
    // d2 = -r * cosZ + SafeSqrt(det);
    float d = max(0.0f, -r * cosZ + SafeSqrt(disc));

    float u = clamp(rho / h, 0.0f, 0.99f);
    float v = clamp((d - dMin) / (dMax - dMin), 0.0f, 0.99f);

    return vec2(u, v);
}

vec3 SampleTransmittance(float r, float cosZ, float rb, float rt)
{
    return texture(FLY_ACCESS_TEXTURE_BUFFER(
                       Textures, gPushConstants.transmittanceMapIndex),
                   TransmittanceParamsToUV(r, cosZ, rb, rt))
        .rgb;
}

vec3 IntegratePsi(vec3 worldPos, vec3 l, float rb, float rt, uint it1, uint it2)
{
    vec3 groundAlbedo = vec3(0.3);
    vec3 fms = vec3(0.0f);
    vec3 illum = vec3(0.0f);
    vec3 planetOrigin = vec3(0.0f);

    float delta1 = 1.0f / it1;

    for (uint i = 0; i < it1; i++)
    {
        float fi = float(i) + 0.5f;
        float phi = acos(1.0f - 2.0f * fi / float(it1));
        float theta = PI * GOLDEN_RATIO * fi;
        vec3 dir = vec3(sin(phi) * sin(theta), cos(phi), sin(phi) * cos(theta));

        float integrationLength =
            RaySphereIntersect(worldPos, dir, planetOrigin, rt);
        if (integrationLength < 0)
        {
            return vec3(0.0f);
        }

        float groundDist = RaySphereIntersect(worldPos, dir, planetOrigin, rb);
        if (groundDist > 0.0f)
        {
            integrationLength = groundDist;
        }

        float delta2 = integrationLength / it2;
        vec3 lum = vec3(0.0f);
        vec3 lumF = vec3(0.0f);
        vec3 transmittance = vec3(1.0f);

        for (uint j = 0; j < it2; j++)
        {
            float fj = float(j) + 0.5f;
            vec3 p = worldPos + fj * dir * delta2;

            float r = length(p);
            float height = max(r - rb, 0.0f);
            float cosZ = dot(l, worldPos / r);
            float vis = RaySphereIntersect(p, l, planetOrigin, rb);

            vec3 extinction = SampleExtinction(height);
            vec3 stepTransmittance = exp(-delta2 * extinction);
            vec3 scatteringNoPhase = SampleScattering(height);
            // Assuming extinction is constant on step segment
            // Integrating analytically
            lumF += transmittance * (scatteringNoPhase *
                                     (1.0f - stepTransmittance) / extinction);

            vec3 s = SampleTransmittance(r, cosZ, rb, rt) * float(vis > 0.0f);
            vec3 scattering = scatteringNoPhase * PHASE_UNIFORM;

            lum += transmittance *
                   ((scattering * s) * (1.0f - stepTransmittance) / extinction);

            transmittance *= stepTransmittance;
        }

        // if (groundDist > 0.0f)
        // {
        //     vec3 p = worldPos + groundDist * dir;
        //     float r = length(p);
        //     float height = max(r - rb, 0.0f);
        //     float cosZ = dot(l, worldPos / r);

        //     lum += SampleTransmittance(r, cosZ, rb, rt) * transmittance *
        //            groundAlbedo * max(dot(normalize(p), l), 0.0f);
        // }

        fms += lumF * delta1;
        illum += lum * delta1;
    }
    // fms *= PHASE_UNIFORM;
    // illum *= PHASE_UNIFORM;
    return illum / (1.0f - fms);
}

vec2 TexToRadiusCosZenith(vec2 uv, float rb, float rt)
{
    float r = mix(rb, rt, uv.y);
    float cosZ = 2.0f * uv.x - 1.0f;
    return vec2(r, cosZ);
}

void main()
{
    vec2 dims = FLY_ACCESS_UNIFORM_BUFFER(AtmosphereParams,
                                          gPushConstants.atmosphereBufferIndex,
                                          multiscatteringMapDims);
    vec2 uv = (gl_GlobalInvocationID.xy + 0.5f) / dims;

    float rb = FLY_ACCESS_UNIFORM_BUFFER(
        AtmosphereParams, gPushConstants.atmosphereBufferIndex, rb);
    float rt = FLY_ACCESS_UNIFORM_BUFFER(
        AtmosphereParams, gPushConstants.atmosphereBufferIndex, rt);

    vec2 rcz = TexToRadiusCosZenith(uv, rb, rt);
    vec3 t = SampleTransmittance(rcz.x, rcz.y, rb, rt);

    vec3 worldPos = vec3(0.0f, rcz.x, 0.0f);
    vec3 l = vec3(SafeSqrt(1.0f - rcz.y * rcz.y), rcz.y, 0.0f);

    vec3 psi = IntegratePsi(worldPos, l, rb, rt, 200, 30);

    imageStore(FLY_ACCESS_STORAGE_TEXTURE_BUFFER(
                   RGBA16FTextures, gPushConstants.multiscatteringMapIndex),
               ivec2(gl_GlobalInvocationID.xy), vec4(psi, 1.0f));
}
