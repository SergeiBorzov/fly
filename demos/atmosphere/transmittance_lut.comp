#version 460
#extension GL_GOOGLE_include_directive : enable
#include "bindless.glsl"

#include "common.glsl"

layout(local_size_x = 16, local_size_y = 16) in;

layout(push_constant) uniform PushConstants
{
    uint atmosphereBufferIndex;
    uint transmittanceMapIndex;
}
gPushConstants;

vec2 UVToTransmittanceRadiusCosZenith(vec2 uv, float rb, float rt)
{
    // max dist to horizon for point inside atmosphere bounds
    float h = sqrt(rt * rt - rb * rb);
    float rho = h * uv.y; // distance to horizon
    float r = sqrt(rho * rho + rb * rb);

    float dMin = rt - r;
    float dMax = rho + h;
    float d = mix(dMin, dMax, uv.x);

    // According to cosine rule
    float cosZ = (d < 1e-5) ? 1.0f : (rt * rt - r * r - d * d) / (2 * r * d);
    cosZ = clamp(cosZ, -1.0f, 1.0f);

    return vec2(r, cosZ);
}

vec3 IntegrateOpticalDepth(vec3 worldPos, vec3 l, float rb, float rt,
                           uint sampleCount)
{
    vec3 planetOrigin = vec3(0.0f);
    float integrationLength = RaySphereIntersect(worldPos, l, planetOrigin, rt);
    integrationLength = max(integrationLength, 0.0f);
    float delta = integrationLength / float(sampleCount);

    vec3 opticalDepth = vec3(0.0f);
    for (uint i = 0; i < sampleCount; i++)
    {
        float fi = float(i);
        vec3 p = worldPos + fi * delta * l;
        float height = max(length(p) - rb, 0.0f);
        opticalDepth +=
            SampleExtinction(height, gPushConstants.atmosphereBufferIndex) *
            delta;
    }

    return opticalDepth;
}

void main()
{
    float rb = FLY_ACCESS_UNIFORM_BUFFER(
        AtmosphereParams, gPushConstants.atmosphereBufferIndex, rb);
    float rt = FLY_ACCESS_UNIFORM_BUFFER(
        AtmosphereParams, gPushConstants.atmosphereBufferIndex, rt);

    vec2 dims = FLY_ACCESS_UNIFORM_BUFFER(AtmosphereParams,
                                          gPushConstants.atmosphereBufferIndex,
                                          transmittanceMapDims);
    vec2 uv = (gl_GlobalInvocationID.xy + 0.5f) / dims;
    vec2 rcz = UVToTransmittanceRadiusCosZenith(uv, rb, rt);

    vec3 worldPos = vec3(0.0f, rcz.x, 0.0f);
    vec3 l = vec3(sqrt(1.0f - rcz.y * rcz.y), rcz.y, 0.0f);

    vec3 transmittance = exp(-IntegrateOpticalDepth(worldPos, l, rb, rt, 500));

    imageStore(
        FLY_ACCESS_STORAGE_TEXTURE_BUFFER(StorageTexturesRGBA16F,
                                          gPushConstants.transmittanceMapIndex),
        ivec2(gl_GlobalInvocationID.xy), vec4(transmittance, 1.0f));
}
