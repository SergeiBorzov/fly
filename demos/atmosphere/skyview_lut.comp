#version 460
#extension GL_GOOGLE_include_directive : enable
#include "common.glsl"

layout(local_size_x = 16, local_size_y = 16) in;

layout(push_constant) uniform PushConstants
{
    uint atmosphereBufferIndex;
    uint cameraBufferIndex;
    uint transmittanceMapIndex;
    uint multiscatteringMapIndex;
    uint skyviewMapIndex;
}
gPushConstants;

FLY_REGISTER_UNIFORM_BUFFER(Camera, {
    mat4 projection;
    mat4 view;
})

vec2 UVToSkyviewLonLat(vec2 uv)
{
    float lon = uv.x * 2.0f * PI;
    float k = 2.0f * uv.y - 1.0f;
    float lat = sign(k) * (k * k) * PI * 0.5f;
    return vec2(lon, lat);
}

vec3 IntegrateLuminance(vec3 camPos, vec3 e, vec3 l, vec3 dir, float rb,
                        float rt, uint sampleCount)
{
    vec3 groundAlbedo = vec3(0.1f);
    vec3 planetOrigin = vec3(0.0f);
    vec3 lum = vec3(0.0f);
    vec3 transmittance = vec3(1.0f);

    float integrationLength = RaySphereIntersect(camPos, dir, planetOrigin, rt);
    if (integrationLength < 0)
    {
        return vec3(0.0f);
    }

    float groundDist = RaySphereIntersect(camPos, dir, planetOrigin, rb);
    if (groundDist > 0.0f)
    {
        integrationLength = groundDist;
    }

    float delta = integrationLength / sampleCount;

    for (uint i = 0; i < sampleCount; i++)
    {
        float fi = float(i) + 0.5f;
        vec3 p = camPos + fi * dir * delta;

        // float r = length(p);
        // float height = max(r - rb, 0.0f);
        // float cosZ = dot(l, normalize(p));

        float height = max(p.y - rb, 0.0f);
        float cosZ = l.y;

        float cosTheta = dot(dir, l);
        float vis = RaySphereIntersect(p, l, planetOrigin, rb);

        vec3 extinction =
            max(SampleExtinction(height, gPushConstants.atmosphereBufferIndex),
                1e-4);
        vec3 stepTransmittance = exp(-delta * extinction);
        vec3 scatteringPhase =
            SampleRayleighScattering(height,
                                     gPushConstants.atmosphereBufferIndex) *
                PhaseRayleigh(cosTheta) +
            SampleMieScattering(height, gPushConstants.atmosphereBufferIndex) *
                PhaseMie(cosTheta, MIE_G);
        vec3 scattering =
            SampleScattering(height, gPushConstants.atmosphereBufferIndex);
        vec3 s = SampleTransmittance(max(p.y, rb), cosZ, rb, rt,
                                     gPushConstants.transmittanceMapIndex);

        vec3 totalScattered = vec3(0.0f);
        totalScattered += float(vis < 0.0f) * s * scatteringPhase;
        totalScattered +=
            scattering *
            SampleMultiscattering(max(p.y, rb), cosZ, rb, rt,
                                  gPushConstants.multiscatteringMapIndex);
        lum += transmittance * totalScattered * e * (1.0f - stepTransmittance) /
               extinction;

        transmittance *= stepTransmittance;
    }

    if (groundDist > 0.0f)
    {
        vec3 p = camPos + dir * groundDist;
        // float r = length(p);
        // float height = max(r - rb, 0.0f);
        // float cosZ = dot(l, normalize(p));

        float height = max(p.y - rb, 0.0f);
        float cosZ = l.y;

        lum += SampleTransmittance(max(p.y, rb), cosZ, rb, rt,
                                   gPushConstants.transmittanceMapIndex) *
               transmittance * (groundAlbedo / PI) *
               max(dot(normalize(p), l), 0.0f);
    }

    return lum;
}

void main()
{
    vec2 dims = FLY_ACCESS_UNIFORM_BUFFER(
        AtmosphereParams, gPushConstants.atmosphereBufferIndex, skyviewMapDims);
    vec2 uv = (gl_GlobalInvocationID.xy + 0.5f) / dims;

    float rb = FLY_ACCESS_UNIFORM_BUFFER(
        AtmosphereParams, gPushConstants.atmosphereBufferIndex, rb);
    float rt = FLY_ACCESS_UNIFORM_BUFFER(
        AtmosphereParams, gPushConstants.atmosphereBufferIndex, rt);
    float zenith = FLY_ACCESS_UNIFORM_BUFFER(
        AtmosphereParams, gPushConstants.atmosphereBufferIndex, zenith);
    float azimuth = FLY_ACCESS_UNIFORM_BUFFER(
        AtmosphereParams, gPushConstants.atmosphereBufferIndex, azimuth);

    vec2 lonLat = UVToSkyviewLonLat(uv);
    vec3 dir = normalize(vec3(cos(lonLat.y) * cos(lonLat.x), sin(lonLat.y),
                              cos(lonLat.y) * sin(lonLat.x))); // -v

    mat4 view = FLY_ACCESS_UNIFORM_BUFFER(
        Camera, gPushConstants.cameraBufferIndex, view);
    vec3 camPos = inverse(view)[3].xyz;

    vec3 worldPos = (camPos * 0.001f);
    worldPos.y += rb;

    vec3 l = SphereCoordToRay(radians(zenith), radians(azimuth));

    vec3 e = vec3(1.0, 1.0f, 1.0f) * 16.0f;
    vec3 lum = IntegrateLuminance(worldPos, e, l, dir, rb, rt, 128);

    imageStore(FLY_ACCESS_STORAGE_TEXTURE_BUFFER(
                   StorageTexturesRGBA16F, gPushConstants.skyviewMapIndex),
               ivec2(gl_GlobalInvocationID.xy), vec4(lum, 1.0f));
}
