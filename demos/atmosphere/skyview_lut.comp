#version 460
#extension GL_GOOGLE_include_directive : enable
#include "common.glsl"

layout(local_size_x = 16, local_size_y = 16) in;

layout(push_constant) uniform PushConstants
{
    uint atmosphereBufferIndex;
    uint cameraBufferIndex;
    uint transmittanceMapIndex;
    uint multiscatteringMapIndex;
    uint skyviewMapIndex;
}
gPushConstants;

FLY_REGISTER_UNIFORM_BUFFER(Camera, {
    mat4 projection;
    mat4 view;
})

vec2 UVToSkyviewLonLat(vec2 uv)
{
    float lon = PI * 0.5f - uv.x * 2.0f * PI;
    float k = 1.0f - 2.0f * uv.y;
    float lat = sign(k) * (k * k) * PI * 0.5f;
    return vec2(lon, lat);
}

vec3 IntegrateLuminance(vec3 camPos, vec3 e, vec3 l, vec3 v, float rb, float rt,
                        uint sampleCount)
{
    vec3 groundAlbedo = vec3(0.1f);
    vec3 planetOrigin = vec3(0.0f);
    vec3 lum = vec3(0.0f);
    vec3 transmittance = vec3(1.0f);

    float integrationLength = RaySphereIntersect(camPos, v, planetOrigin, rt);
    if (integrationLength < 0)
    {
        return vec3(0.0f);
    }

    float groundDist = RaySphereIntersect(camPos, v, planetOrigin, rb);
    if (groundDist > 0.0f)
    {
        integrationLength = groundDist;
    }

    float delta = integrationLength / sampleCount;

    for (uint i = 0; i < sampleCount; i++)
    {
        float fi = float(i) + 0.5f;
        vec3 p = camPos + fi * v * delta; // v points to eye
        float height = max(p.y - rb, 0.0f);
        float cosZ = l.y;
        float cosTheta = dot(v, l);
        float vis = RaySphereIntersect(p, l, planetOrigin, rb);

        vec3 extinction =
            SampleExtinction(height, gPushConstants.atmosphereBufferIndex);
        vec3 stepTransmittance = exp(-delta * extinction);
        vec3 scatteringPhase =
            SampleRayleighScattering(height,
                                     gPushConstants.atmosphereBufferIndex) *
                PhaseRayleigh(cosTheta) +
            SampleMieScattering(height, gPushConstants.atmosphereBufferIndex) *
                PhaseMie(cosTheta, MIE_G);
        vec3 scattering =
            SampleScattering(height, gPushConstants.atmosphereBufferIndex);
        vec3 s = SampleTransmittance(p.y, cosZ, rb, rt,
                                     gPushConstants.transmittanceMapIndex);

        vec3 totalScattered = vec3(0.0f);
        totalScattered += s * scatteringPhase;
        totalScattered +=
            scattering *
            SampleMultiscattering(p.y, cosZ, rb, rt,
                                  gPushConstants.transmittanceMapIndex);
        lum += float(vis < 0.0f) * (transmittance * totalScattered * e *
                                    (1.0f - stepTransmittance) / extinction);

        transmittance *= stepTransmittance;
    }

    if (groundDist > 0.0f)
    {
        vec3 p = camPos + v * groundDist;
        float height = max(p.y - rb, 0.0f);
        float cosZ = l.y;

        lum += SampleTransmittance(p.y, cosZ, rb, rt,
                                   gPushConstants.transmittanceMapIndex) *
               transmittance * groundAlbedo * max(dot(normalize(p), l), 0.0f);
    }

    return lum;
}

void main()
{
    vec2 dims = FLY_ACCESS_UNIFORM_BUFFER(
        AtmosphereParams, gPushConstants.atmosphereBufferIndex, skyviewMapDims);
    vec2 uv = (gl_GlobalInvocationID.xy + 0.5f) / dims;

    float rb = FLY_ACCESS_UNIFORM_BUFFER(
        AtmosphereParams, gPushConstants.atmosphereBufferIndex, rb);
    float rt = FLY_ACCESS_UNIFORM_BUFFER(
        AtmosphereParams, gPushConstants.atmosphereBufferIndex, rt);
    float zenith = FLY_ACCESS_UNIFORM_BUFFER(
        AtmosphereParams, gPushConstants.atmosphereBufferIndex, zenith);
    float azimuth = FLY_ACCESS_UNIFORM_BUFFER(
        AtmosphereParams, gPushConstants.atmosphereBufferIndex, azimuth);

    vec2 lonLat = UVToSkyviewLonLat(uv);
    // pi/2 - angles?
    vec3 dir = SphereCoordToRay(lonLat.y, lonLat.x);
    // vec3 dir = vec3(cos(lonLat.y) * cos(lonLat.x), sin(lonLat.y),
    //                 cos(lonLat.y) * sin(lonLat.x)); // -v

    mat4 view = FLY_ACCESS_UNIFORM_BUFFER(
        Camera, gPushConstants.cameraBufferIndex, view);
    vec3 camPos = inverse(view)[3].xyz;

    vec3 l = SphereCoordToRay(radians(zenith), radians(azimuth));

    vec3 e = vec3(1.0, 1.0f, 1.0f) * 16.0f;
    vec3 lum = IntegrateLuminance(camPos, e, l, dir, rb, rt, 300);

    imageStore(FLY_ACCESS_STORAGE_TEXTURE_BUFFER(
                   StorageTexturesRGBA16F, gPushConstants.skyviewMapIndex),
               ivec2(gl_GlobalInvocationID.xy), vec4(lum, 1.0f));
}
