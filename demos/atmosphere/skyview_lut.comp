#version 460
#extension GL_GOOGLE_include_directive : enable
#include "common.glsl"

#define SKYVIEW_STEP_COUNT 30
layout(local_size_x = 16, local_size_y = 16) in;

layout(push_constant) uniform PushConstants
{
    uint atmosphereBufferIndex;
    uint cameraBufferIndex;
    uint transmittanceMapIndex;
    uint multiscatteringMapIndex;
    uint skyviewMapIndex;
}
gPushConstants;

FLY_REGISTER_UNIFORM_BUFFER(Camera, {
    mat4 projection;
    mat4 view;
})

vec3 IntegrateLuminance(vec3 camPos, vec3 e, vec3 l, vec3 dir, float rb,
                        float rt)
{
    vec3 groundAlbedo = vec3(0.1f);
    vec3 planetOrigin = vec3(0.0f);
    vec3 lum = vec3(0.0f);

    float integrationLength = RaySphereIntersect(camPos, dir, planetOrigin, rt);
    if (integrationLength < 0)
    {
        return vec3(0.0f);
    }

    float groundDist = RaySphereIntersect(camPos, dir, planetOrigin, rb);
    if (groundDist > 0.0f)
    {
        integrationLength = groundDist;
    }

    float delta = integrationLength / float(SKYVIEW_STEP_COUNT);

    float cosTheta = dot(dir, l);
    float phaseR = PhaseRayleigh(cosTheta);
    float phaseM = PhaseMie(cosTheta, MIE_G);
    vec3 transmittance = vec3(1.0f);

    for (uint i = 0; i < SKYVIEW_STEP_COUNT; i++)
    {
        float fi = float(i) + 0.5f;
        vec3 p = camPos + fi * dir * delta;

        // float r = length(p);
        // float height = max(r - rb, 0.0f);
        // float cosZ = dot(l, normalize(p));

        float r = p.y;
        float height = max(p.y - rb, 0.0f);
        float cosZ = l.y;

        vec3 extinction =
            max(SampleExtinction(height, gPushConstants.atmosphereBufferIndex),
                1e-7);
        vec3 stepTransmittance = exp(-delta * extinction);

        vec3 scatteringR = SampleRayleighScattering(
            height, gPushConstants.atmosphereBufferIndex);
        vec3 scatteringM =
            SampleMieScattering(height, gPushConstants.atmosphereBufferIndex);

        float groundT = RaySphereIntersect(p, l, planetOrigin, rb);
        vec3 s = float(groundT < 0.0f) *
                 SampleTransmittance(r, cosZ, rb, rt,
                                     gPushConstants.transmittanceMapIndex);

        vec3 transmittanceDelta =
            transmittance * (1.0f - stepTransmittance) / extinction;

        // single scattering
        lum += (scatteringR * phaseR + scatteringM * phaseM) * s *
               transmittance * (1.0f - stepTransmittance) / extinction;

        // multi scattering
        lum += (scatteringR + scatteringM) *
               SampleMultiscattering(height, cosZ, rb, rt,
                                     gPushConstants.multiscatteringMapIndex);

        transmittance *= stepTransmittance;
    }

    return e * lum;

    // if (groundDist > 0.0f)
    // {
    //     vec3 p = camPos + dir * groundDist;
    //     float r = length(p);
    //     float height = max(r - rb, 0.0f);
    //     float cosZ = dot(l, normalize(p));

    //     // float height = max(p.y - rb, 0.0f);
    //     // float cosZ = l.y;

    //     lum += SampleTransmittance(max(r, rb), cosZ, rb, rt,
    //                                gPushConstants.transmittanceMapIndex) *
    //            transmittance * (groundAlbedo / PI) *
    //            max(dot(normalize(p), l), 0.0f);
    // }
}

void main()
{
    vec2 dims = FLY_ACCESS_UNIFORM_BUFFER(
        AtmosphereParams, gPushConstants.atmosphereBufferIndex, skyviewMapDims);
    vec2 uv = (gl_GlobalInvocationID.xy + 0.5f) / dims;

    float rb = FLY_ACCESS_UNIFORM_BUFFER(
        AtmosphereParams, gPushConstants.atmosphereBufferIndex, rb);
    float rt = FLY_ACCESS_UNIFORM_BUFFER(
        AtmosphereParams, gPushConstants.atmosphereBufferIndex, rt);
    float zenith = FLY_ACCESS_UNIFORM_BUFFER(
        AtmosphereParams, gPushConstants.atmosphereBufferIndex,
        sunZenithRadians);
    float azimuth = FLY_ACCESS_UNIFORM_BUFFER(
        AtmosphereParams, gPushConstants.atmosphereBufferIndex,
        sunAzimuthRadians);

    vec2 lonLat = UVToSkyviewLonLat(uv);
    vec3 dir = SphereCoordToRay(lonLat.y, lonLat.x); // -v

    mat4 view = FLY_ACCESS_UNIFORM_BUFFER(
        Camera, gPushConstants.cameraBufferIndex, view);
    vec3 camPos = inverse(view)[3].xyz;

    vec3 worldPos = (camPos * 0.001f);
    worldPos.y += rb;

    vec3 l = SphereCoordToRay(PI / 2 - zenith, azimuth);

    vec3 sunAlbedo = FLY_ACCESS_UNIFORM_BUFFER(
        AtmosphereParams, gPushConstants.atmosphereBufferIndex, sunAlbedo);
    vec3 sunIlluminance = FLY_ACCESS_UNIFORM_BUFFER(
        AtmosphereParams, gPushConstants.atmosphereBufferIndex,
        sunIlluminanceOuterSpace);

    vec3 e = sunAlbedo * sunIlluminance * 1e-5;
    vec3 lum = IntegrateLuminance(worldPos, e, l, dir, rb, rt);

    imageStore(FLY_ACCESS_STORAGE_TEXTURE_BUFFER(
                   StorageTexturesRGBA16F, gPushConstants.skyviewMapIndex),
               ivec2(gl_GlobalInvocationID.xy), vec4(lum, 1.0f));
}
